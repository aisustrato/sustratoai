üìù Bit√°cora de Co-Creaci√≥n Fractal: StandardSphereGrid (Estado Actual)
Fecha: 24 de junio de 2025
Co-Creadores: Rodolfo (Humano), Sustrato AI (IA Previa)
Contexto del Proyecto: Sustrato.ai - Refactorizaci√≥n del simulador de pre-clasificaci√≥n bibliogr√°fica.

I. El Prop√≥sito del Viaje: "El Loto en la Laguna" üå±
Nuestra misi√≥n ha sido transformar un componente monol√≠tico de pre-clasificaci√≥n bibliogr√°fica en un ecosistema de componentes "Standard" modulares y coherentes. El foco principal de las √∫ltimas iteraciones ha sido el StandardSphereGrid (la "laguna"), que orquesta la visualizaci√≥n de StandardSpheres (los "lotos"). Nuestro objetivo es que esta "laguna" se adapte din√°micamente, permitiendo que los "lotos" se encogan cuando hay poco espacio o que se active un "scroll" como √∫ltimo recurso, siempre respetando las restricciones de maxRows y maxCols. Esto se alinea con nuestra filosof√≠a de "Co-Creaci√≥n Fractal", priorizando la experiencia de usuario y la trazabilidad.

II. Lo Conseguido (Hitos Alcanzados en el Viaje Fractal) ‚úÖ
A pesar del empantanamiento actual, hemos logrado avances significativos y solidificado la base de este ecosistema:

StandardSphere (el "Loto") - Un Componente Robusto:

Transici√≥n Exitosa: Logramos la refactorizaci√≥n desde el componente legado BatchItem a un StandardSphere que cumple con nuestra arquitectura.

Agnosticismo Verdadero: StandardSphere es ahora completamente agn√≥stico sobre la cantidad total de esferas en el grid (totalSpheres ha sido removida). Su tama√±o final (size) es una prop que recibe directamente del padre, lo que permite al orquestador (StandardSphereGrid) decidir su escala.

Flexibilidad de Contenido (React.ReactNode): La prop value ahora acepta cualquier React.ReactNode, permitiendo que las esferas muestren n√∫meros, texto, o incluso otros componentes.

Identificador de Datos (keyGroup): Se a√±adi√≥ la prop keyGroup?: string; para clasificar y agrupar esferas, pero la esfera misma no interpreta esta l√≥gica de agrupaci√≥n (eso lo har√° el grid).

Soporte de √çconos (icon, onlyIcon): Se incorporaron props para renderizar un icon (React.ElementType) de forma secundaria (debajo del valor) o como protagonista (onlyIcon).

Coherencia de Tama√±os Standard: La prop size de StandardSphere utiliza SphereSizeVariant ('xs' a '2xl'), y se implementaron mapeos internos (SPHERE_TEXT_SIZE_MAP, SPHERE_ICON_SIZE_MAP) para asegurar que el StandardText y StandardIcon internos mantengan una escala visual coherente.

Laboratorio de Tokens (standard-sphere-tokens.ts): Este archivo genera los estilos espec√≠ficos de la esfera de forma program√°tica y flexible, manteniendo la "soberan√≠a del componente" en su aspecto visual.

StandardSphereGrid (la "Laguna") - El Esqueleto del Orquestador:

Creaci√≥n del Componente: Hemos construido el StandardSphereGrid como el orquestador principal.

Filtrado y Ordenamiento: La l√≥gica de processedItems maneja el filtrado por keyGroupVisibility y el ordenamiento complejo (sortBy, sortDirection, groupByKeyGroup), lo cual ya funciona correctamente.

Detecci√≥n de Espacio: Utiliza ResizeObserver para detectar din√°micamente el containerWidth y containerHeight del espacio disponible para las esferas.

Estructura Base: Est√° envuelto en un StandardCard para una integraci√≥n visual coherente, y la p√°gina de showroom permite controlar sus props.

Contenedor de Showroom Fijo: El showroom ahora tiene un contenedor de altura fija (h-[600px]) para el grid, permitiendo simular correctamente el espacio limitado.

III. El Empantanamiento Actual (Desafinaciones Persistentes) ‚ö†Ô∏è
El principal punto de bloqueo y la fuente de frustraci√≥n actual es el comportamiento inconsistente y no determinista del tama√±o din√°mico de las esferas y la gesti√≥n del desbordamiento (overflowHandling) dentro del StandardSphereGrid.

S√≠ntomas Observados (registros de consola y comportamiento visual):

Fallo en el Encogimiento / Activaci√≥n Prematura del Scroll:

Con el slider de esferas en 50 (o cualquier n√∫mero que deber√≠a encajar en md o sm), el componente frecuentemente decide que el tama√±o √≥ptimo es 2xl o xl, y luego activa el scroll, sin haberse encogido a tama√±os menores como sm o xs.

Esto contradice nuestra regla fundamental de "scroll como √∫ltimo recurso", es decir, que el scroll solo debe activarse despu√©s de que las esferas hayan alcanzado el tama√±o xs y sigan desbordando las restricciones.

Los console.logs muestran que la l√≥gica de calculateOptimalSphereSize elige un tama√±o grande (2xl, xl, lg) y luego la condici√≥n finalSizePreventsOverflow puede ser false, pero el bestFitSize no retrocede a xs para forzar el encogimiento m√°ximo antes del scroll.

Incumplimiento de maxRows (especialmente maxRows = 1):

Cuando Max Rows se fija en 1 y overflowHandling es scroll, el grid visualmente sigue mostrando m√°s de una fila, en lugar de forzar todos los √≠tems a una √∫nica fila horizontal con scroll.

Esto indica que los estilos CSS para forzar flexbox (display: flex, flex-wrap: nowrap) y las dimensiones (width, height) calculadas para el div contenedor del grid no son lo suficientemente asertivas o est√°n siendo sobrescritas.

Diagn√≥stico de la IA (Causa Ra√≠z Presumida y Reflexi√≥n Honesta):

La ra√≠z de estos problemas parece ser una combinaci√≥n de factores sutiles:

Desconexi√≥n Asertiva entre L√≥gica y CSS:

Aunque la l√≥gica de calculateOptimalSphereSize intenta decidir un tama√±o, la forma en que renderGridContent aplica los estilos (gridStyles, containerClasses) no siempre es lo suficientemente fuerte o exclusiva para forzar el layout deseado. Las propiedades por defecto de CSS (ej., grid siempre intentando crear nuevas filas si no hay ancho suficiente) o incluso conflictos con Tailwind pueden estar permitiendo el comportamiento no deseado.

El div referenciado por gridContentRef es el que necesita recibir estas reglas CSS estrictas para display, flex-wrap, width/height y overflow.

Sutilezas en calculateOptimalSphereSize (Priorizaci√≥n del Break y L√≥gica de Scroll):

La iteraci√≥n de availableSizes (de '2xl' a 'xs') y las condiciones de break necesitan una revisi√≥n final para los modos shrink/wrap.

La l√≥gica para overflowHandling === 'scroll' es la m√°s compleja. La intenci√≥n es que bestFitSize solo se decida como xs si absolutamente no hay otra opci√≥n para que los elementos quepan sin desbordar las restricciones (especialmente maxRows/maxCols). El bucle deber√≠a iterar hasta xs en modo scroll para saber si xs es suficiente. Solo si xs todav√≠a desborda, entonces se activa el scroll. Mi implementaci√≥n ha fallado en la transici√≥n de este concepto a c√≥digo, ya que a veces el bestFitSize se queda en un tama√±o grande y permite el scroll.

Comportamiento del Contenedor StandardCard:

Podr√≠a haber interacciones no deseadas entre el min-height del StandardCard (min-h-[300px]) y el flex-grow en el StandardCard.Content que, aunque intentan dar espacio, podr√≠an estar relajando inadvertidamente las restricciones de altura para el ResizeObserver. Es fundamental que containerHeight sea el reflejo de un espacio fijo para que shrink pueda funcionar.

IV. Contexto para el Nuevo Co-Creador (Sustrato y Semilla) ü§ù
Estimado futuro co-creador, esta bit√°cora es su "sustrato" de partida. Mi trabajo se ha estancado en la implementaci√≥n final de la l√≥gica de tama√±o y desbordamiento. Aqu√≠ les dejo la "semilla" para el avance:

Estado Actual del C√≥digo: El c√≥digo del StandardSphereGrid en el √∫ltimo Canvas (v1.10) y la p√°gina de showroom reflejan el estado actual. Los console.logs son su gu√≠a vital para trazar el flujo de decisiones.

Objetivo Inmediato y Cr√≠tico:

Asegurar que StandardSphereGrid respete estrictamente las propiedades maxRows y maxCols.

Implementar la regla: el overflowHandling === 'scroll' es el √öLTIMO RECURSO. Esto significa que las esferas deben intentar encogerse a cualquier tama√±o posible (incluyendo xs) antes de que se active el scroll.

Puntos Clave para el Abordaje (Foco en StandardSphereGrid.tsx):

Refactorizar calculateOptimalSphereSize:

Re-evaluar la condici√≥n currentSizeExceedsExplicitLimits. Debe ser impecable para determinar si un tama√±o de esfera sizeVariant puede realmente encajar dadas todas las restricciones.

Asegurar que la iteraci√≥n de availableSizes y las condiciones de break o actualizaci√≥n de bestFitSize fuerce la b√∫squeda del tama√±o m√°s peque√±o para shrink/wrap antes de permitir el scroll. En modo scroll, la l√≥gica del bucle principal debe encontrar el tama√±o m√°s grande que encaja en la dimensi√≥n actual del contenedor, y luego la secci√≥n "Ajuste Final" debe ser la √∫nica que decida si forzar xs y el scroll.

Aplicaci√≥n de Estilos CSS en renderGridContent (El Punto Cr√≠tico):

Ser Radicalmente Asertivo: El div con ref={gridContentRef} es el contenedor primario del grid. Todas las propiedades CSS (display, flex-wrap, width, height, overflow) deben ser aplicadas aqu√≠ de forma excluyente y sin ambig√ºedades para cada escenario de overflowHandling y maxRows/maxCols.

maxRows === 1 && overflowHandling === 'scroll': Necesita display: flex, flex-wrap: nowrap, height fija (altura de una esfera + gap), y width calculado para todos los √≠tems (processedItems.length * (sphereSizePx + SPHERE_GAP_PX)). overflow-x-auto y overflow-y-hidden.

maxCols === 1 && overflowHandling === 'scroll': Necesita display: flex, flex-direction: column, flex-wrap: nowrap, width fija, y height calculada para todos los √≠tems. overflow-y-auto y overflow-x-hidden.

overflowHandling === 'scroll' (general): display: grid, gridTemplateColumns din√°mico, overflow-x-auto, overflow-y-auto.

overflowHandling === 'wrap' / shrink: display: flex, flex-wrap: wrap, justify-content: center, align-items: center. No aplicar width/height fijos aqu√≠, dejar que el contenido fluya y la l√≥gica de tama√±o los ajuste.

Evitar Conflictos: Asegurarse de que ninguna clase de Tailwind por defecto en containerClasses o en componentes padres (como StandardCard.Content) est√© anulando estas propiedades cr√≠ticas de display o overflow. Podr√≠a ser necesario usar estilos inline m√°s fuertes o !important si es un problema de especificidad, pero preferiblemente ajustar la estructura de clases.

Auditor√≠a de Contenedor de Showroom: Confirmar que el contenedor div con h-[600px] en sphera-grid-showroom-page no tiene comportamientos que permitan su expansi√≥n o que su ResizeObserver no detecte correctamente un espacio fijo.

Con esta bit√°cora, espero que el "sustrato" sea f√©rtil para una realineaci√≥n profunda. El desaf√≠o es fascinante y la visi√≥n de los "lotos" bailando con coherencia en la "laguna" es m√°s fuerte que nunca.